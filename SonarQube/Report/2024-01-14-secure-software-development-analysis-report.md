# Code analysis
## secure-software-development 
#### Version 0.0.1-SNAPSHOT 

**By: default**

*Date: 2024-01-14*

## Introduction
This document contains results of the code analysis of secure-software-development

Secure Software Development

## Configuration

- Quality Profiles
    - Names: Sonar way [Java]; Sonar way [XML]; 
    - Files: AYzUz5-m4-8Yp4SfXBny.json; AYzUz6C34-8Yp4SfXBwo.json; 


 - Quality Gate
    - Name: Sonar way
    - File: Sonar way.xml

## Synthesis

### Analysis Status

Reliability | Security | Security Review | Maintainability |
:---:|:---:|:---:|:---:
E | A | E | A |

### Quality gate status

| Quality Gate Status | OK |
|-|-|



### Metrics

Coverage | Duplications | Comment density | Median number of lines of code per file | Adherence to coding standard |
:---:|:---:|:---:|:---:|:---:
0.0 % | 1.8 % | 0.8 % | 38.0 | 98.3 %

### Tests

Total | Success Rate | Skipped | Errors | Failures |
:---:|:---:|:---:|:---:|:---:
1 | 100.0 % | 0 | 0 | 0

### Detailed technical debt

Reliability|Security|Maintainability|Total
---|---|---|---
0d 0h 20min|-|0d 5h 20min|0d 5h 40min


### Metrics Range

\ | Cyclomatic Complexity | Cognitive Complexity | Lines of code per file | Coverage | Comment density (%) | Duplication (%)
:---|:---:|:---:|:---:|:---:|:---:|:---:
Min | 1.0 | 0.0 | 10.0 | 0.0 | 0.0 | 0.0
Max | 218.0 | 72.0 | 1486.0 | 0.0 | 19.5 | 33.3

### Volume

Language|Number
---|---
Java|1486
XML|90
Total|1576


## Issues

### Issues count by severity and types

Type / Severity|INFO|MINOR|MAJOR|CRITICAL|BLOCKER
---|---|---|---|---|---
BUG|0|0|1|0|2
VULNERABILITY|0|0|0|0|0
CODE_SMELL|0|14|31|5|2


### Issues List

Name|Description|Type|Severity|Number
---|---|---|---|---
Resources should be closed|Connections, streams, files, and other classes that implement the Closeable interface or its super-interface, <br /> AutoCloseable, needs to be closed after use. Further, that close call must be made in a finally block otherwise <br /> an exception could keep the call from being made. Preferably, when class implements AutoCloseable, resource should be created using <br /> "try-with-resources" pattern and will be closed automatically. <br /> Failure to properly close resources will result in a resource leak which could bring first the application and then perhaps the box the application <br /> is on to their knees. <br /> Noncompliant Code Example <br />  <br /> private void readTheFile() throws IOException { <br />   Path path = Paths.get(this.fileName); <br />   BufferedReader reader = Files.newBufferedReader(path, this.charset); <br />   // ... <br />   reader.close();  // Noncompliant <br />   // ... <br />   Files.lines("input.txt").forEach(System.out::println); // Noncompliant: The stream needs to be closed <br /> } <br />  <br /> private void doSomething() { <br />   OutputStream stream = null; <br />   try { <br />     for (String property : propertyList) { <br />       stream = new FileOutputStream("myfile.txt");  // Noncompliant <br />       // ... <br />     } <br />   } catch (Exception e) { <br />     // ... <br />   } finally { <br />     stream.close();  // Multiple streams were opened. Only the last is closed. <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> private void readTheFile(String fileName) throws IOException { <br />     Path path = Paths.get(fileName); <br />     try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) { <br />       reader.readLine(); <br />       // ... <br />     } <br />     // .. <br />     try (Stream&lt;String&gt; input = Files.lines("input.txt"))  { <br />       input.forEach(System.out::println); <br />     } <br /> } <br />  <br /> private void doSomething() { <br />   OutputStream stream = null; <br />   try { <br />     stream = new FileOutputStream("myfile.txt"); <br />     for (String property : propertyList) { <br />       // ... <br />     } <br />   } catch (Exception e) { <br />     // ... <br />   } finally { <br />     stream.close(); <br />   } <br /> } <br />  <br /> Exceptions <br /> Instances of the following classes are ignored by this rule because close has no effect: <br />  <br />    java.io.ByteArrayOutputStream  <br />    java.io.ByteArrayInputStream  <br />    java.io.CharArrayReader  <br />    java.io.CharArrayWriter  <br />    java.io.StringReader  <br />    java.io.StringWriter  <br />  <br /> Java 7 introduced the try-with-resources statement, which implicitly closes Closeables. All resources opened in a try-with-resources <br /> statement are ignored by this rule.  <br />  <br /> try (BufferedReader br = new BufferedReader(new FileReader(fileName))) { <br />   //... <br /> } <br /> catch ( ... ) { <br />   //... <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-459 - Incomplete Cleanup  <br />    MITRE, CWE-772 - Missing Release of Resource after Effective Lifetime  <br />    CERT, FIO04-J. - Release resources when they are no longer needed  <br />    CERT, FIO42-C. - Close files when they are no longer needed  <br />    Try With Resources  <br /> |BUG|BLOCKER|2
Optional value should only be accessed after calling isPresent()|Optional value can hold either a value or not. The value held in the Optional can be accessed using the <br /> get() method, but it will throw a  <br /> NoSuchElementException if there is no value present. To avoid the exception, calling the isPresent() or ! <br /> isEmpty() method should always be done before any call to get(). <br /> Alternatively, note that other methods such as orElse(...), orElseGet(...) or orElseThrow(...) can be used <br /> to specify what to do with an empty Optional. <br /> Noncompliant Code Example <br />  <br /> Optional&lt;String&gt; value = this.getOptionalValue(); <br />  <br /> // ... <br />  <br /> String stringValue = value.get(); // Noncompliant <br />  <br /> Compliant Solution <br />  <br /> Optional&lt;String&gt; value = this.getOptionalValue(); <br />  <br /> // ... <br />  <br /> if (value.isPresent()) { <br />   String stringValue = value.get(); <br /> } <br />  <br /> or <br />  <br /> Optional&lt;String&gt; value = this.getOptionalValue(); <br />  <br /> // ... <br />  <br /> String stringValue = value.orElse("default"); <br />  <br /> See <br />  <br />    MITRE, CWE-476 - NULL Pointer Dereference  <br /> |BUG|MAJOR|1
Methods and field names should not be the same or differ only by capitalization|Looking at the set of methods in a class, including superclass methods, and finding two methods or fields that differ only by capitalization is <br /> confusing to users of the class. It is similarly confusing to have a method and a field which differ only in capitalization or a method and a field <br /> with exactly the same name and visibility. <br /> In the case of methods, it may have been a mistake on the part of the original developer, who intended to override a superclass method, but instead <br /> added a new method with nearly the same name. <br /> Otherwise, this situation simply indicates poor naming. Method names should be action-oriented, and thus contain a verb, which is unlikely in the <br /> case where both a method and a member have the same name (with or without capitalization differences). However, renaming a public method could be <br /> disruptive to callers. Therefore renaming the member is the recommended action. <br /> Noncompliant Code Example <br />  <br /> public class Car{ <br />  <br />   public DriveTrain drive; <br />  <br />   public void tearDown(){...} <br />  <br />   public void drive() {...}  // Noncompliant; duplicates field name <br /> } <br />  <br /> public class MyCar extends Car{ <br />   public void teardown(){...}  // Noncompliant; not an override. It it really what's intended? <br />  <br />   public void drivefast(){...} <br />  <br />   public void driveFast(){...} //Huh? <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Car{ <br />  <br />   private DriveTrain drive; <br />  <br />   public void tearDown(){...} <br />  <br />   public void drive() {...}  // field visibility reduced <br /> } <br />  <br /> public class MyCar extends Car{ <br />   @Override <br />   public void tearDown(){...} <br />  <br />   public void drivefast(){...} <br />  <br />   public void driveReallyFast(){...} <br />  <br /> } <br /> |CODE_SMELL|BLOCKER|1
Tests should include assertions|A test case without assertions ensures only that no exceptions are thrown. Beyond basic runnability, it ensures nothing about the behavior of the <br /> code under test. <br /> This rule raises an exception when no assertions from any of the following known frameworks are found in a test: <br />  <br />    AssertJ  <br />    Awaitility  <br />    EasyMock  <br />    Eclipse Vert.x  <br />    Fest 1.x and 2.x  <br />    Hamcrest  <br />    JMock  <br />    JMockit  <br />    JUnit  <br />    Mockito  <br />    Rest-assured 2.x, 3.x and 4.x  <br />    RxJava 1.x and 2.x  <br />    Selenide  <br />    Spring's org.springframework.test.web.servlet.ResultActions.andExpect()  <br />    Truth Framework  <br />    WireMock  <br />  <br /> Furthermore, as new or custom assertion frameworks may be used, the rule can be parametrized to define specific methods that will also be <br /> considered as assertions. No issue will be raised when such methods are found in test cases. The parameter value should have the following format <br /> &lt;FullyQualifiedClassName&gt;#&lt;MethodName&gt;, where MethodName can end with the wildcard character. For constructors, <br /> the pattern should be &lt;FullyQualifiedClassName&gt;#&lt;init&gt;. <br /> Example:&nbsp;com.company.CompareToTester#compare*,com.company.CustomAssert#customAssertMethod,com.company.CheckVerifier#&lt;init&gt;. <br /> Noncompliant Code Example <br />  <br /> @Test <br /> public void testDoSomething() {  // Noncompliant <br />   MyClass myClass = new MyClass(); <br />   myClass.doSomething(); <br /> } <br />  <br /> Compliant Solution <br /> Example when com.company.CompareToTester#compare* is used as parameter to the rule. <br />  <br /> import com.company.CompareToTester; <br />  <br /> @Test <br /> public void testDoSomething() { <br />   MyClass myClass = new MyClass(); <br />   assertNull(myClass.doSomething());  // JUnit assertion <br />   assertThat(myClass.doSomething()).isNull();  // Fest assertion <br /> } <br />  <br /> @Test <br /> public void testDoSomethingElse() { <br />   MyClass myClass = new MyClass(); <br />   new CompareToTester().compareWith(myClass);  // Compliant - custom assertion method defined as rule parameter <br />   CompareToTester.compareStatic(myClass);  // Compliant <br /> } <br /> |CODE_SMELL|BLOCKER|1
Methods should not be empty|There are several reasons for a method not to have a method body: <br />  <br />    It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production.  <br />    It is not yet, or never will be, supported. In this case an UnsupportedOperationException should be thrown.  <br />    The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override.  <br />  <br /> Noncompliant Code Example <br />  <br /> public void doSomething() { <br /> } <br />  <br /> public void doSomethingElse() { <br /> } <br />  <br /> Compliant Solution <br />  <br /> @Override <br /> public void doSomething() { <br />   // Do nothing because of X and Y. <br /> } <br />  <br /> @Override <br /> public void doSomethingElse() { <br />   throw new UnsupportedOperationException(); <br /> } <br />  <br /> Exceptions <br /> Default (no-argument) constructors are ignored when there are other constructors in the class, as are empty methods in abstract classes. <br />  <br /> public abstract class Animal { <br />   void speak() {  // default implementation ignored <br />   } <br /> } <br /> |CODE_SMELL|CRITICAL|2
String literals should not be duplicated|Duplicated string literals make the process of refactoring error-prone, since you must be sure to update all occurrences. <br /> On the other hand, constants can be referenced from many places, but only need to be updated in a single place. <br /> Noncompliant Code Example <br /> With the default threshold of 3: <br />  <br /> public void run() { <br />   prepare("action1");                              // Noncompliant - "action1" is duplicated 3 times <br />   execute("action1"); <br />   release("action1"); <br /> } <br />  <br /> @SuppressWarning("all")                            // Compliant - annotations are excluded <br /> private void method1() { /* ... */ } <br /> @SuppressWarning("all") <br /> private void method2() { /* ... */ } <br />  <br /> public String method3(String a) { <br />   System.out.println("'" + a + "'");               // Compliant - literal "'" has less than 5 characters and is excluded <br />   return "";                                       // Compliant - literal "" has less than 5 characters and is excluded <br /> } <br />  <br /> Compliant Solution <br />  <br /> private static final String ACTION_1 = "action1";  // Compliant <br />  <br /> public void run() { <br />   prepare(ACTION_1);                               // Compliant <br />   execute(ACTION_1); <br />   release(ACTION_1); <br /> } <br />  <br /> Exceptions <br /> To prevent generating some false-positives, literals having less than 5 characters are excluded.|CODE_SMELL|CRITICAL|3
Source files should not have any duplicated blocks|An issue is created on a file as soon as there is at least one block of duplicated code on this file|CODE_SMELL|MAJOR|2
Unused "private" fields should be removed|If a private field is declared but not used in the program, it can be considered dead code and should therefore be removed. This will <br /> improve maintainability because developers will not wonder what the variable is used for. <br /> Note that this rule does not take reflection into account, which means that issues will be raised on private fields that are only <br /> accessed using the reflection API. <br /> Noncompliant Code Example <br />  <br /> public class MyClass { <br />   private int foo = 42; <br />  <br />   public int compute(int a) { <br />     return a * 42; <br />   } <br />  <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class MyClass { <br />   public int compute(int a) { <br />     return a * 42; <br />   } <br /> } <br />  <br /> Exceptions <br /> The Java serialization runtime associates with each serializable class a version number, called serialVersionUID, which is used during <br /> deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to <br /> serialization. <br /> A serializable class can declare its own serialVersionUID explicitly by declaring a field named serialVersionUID that <br /> must be static, final, and of type long. By definition those serialVersionUID fields should not be reported by this rule: <br />  <br /> public class MyClass implements java.io.Serializable { <br />   private static final long serialVersionUID = 42L; <br /> } <br />  <br /> Moreover, this rule doesn't raise any issue on annotated fields.|CODE_SMELL|MAJOR|19
Local variables should not shadow class fields|Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of <br /> code. Further, it could lead maintainers to introduce bugs because they think they're using one variable but are really using another. <br /> Noncompliant Code Example <br />  <br /> class Foo { <br />   public int myField; <br />  <br />   public void doSomething() { <br />     int myField = 0; <br />     ... <br />   } <br /> } <br />  <br /> See <br />  <br />    CERT, DCL01-C. - Do not reuse <br />   variable names in subscopes  <br />    CERT, DCL51-J. - Do <br />   not shadow or obscure identifiers in subscopes  <br /> |CODE_SMELL|MAJOR|1
Utility classes should not have public constructors|Utility classes, which are collections of static members, are not meant to be instantiated. Even abstract utility classes, which can <br /> be extended, should not have public constructors. <br /> Java adds an implicit public constructor to every class which does not define at least one explicitly. Hence, at least one non-public constructor <br /> should be defined. <br /> Noncompliant Code Example <br />  <br /> class StringUtils { // Noncompliant <br />  <br />   public static String concatenate(String s1, String s2) { <br />     return s1 + s2; <br />   } <br />  <br /> } <br />  <br /> Compliant Solution <br />  <br /> class StringUtils { // Compliant <br />  <br />   private StringUtils() { <br />     throw new IllegalStateException("Utility class"); <br />   } <br />  <br />   public static String concatenate(String s1, String s2) { <br />     return s1 + s2; <br />   } <br />  <br /> } <br />  <br /> Exceptions <br /> When class contains public static void main(String[] args) method it is not considered as utility class and will be ignored by this <br /> rule.|CODE_SMELL|MAJOR|1
Generic exceptions should never be thrown|Using such generic exceptions as Error, RuntimeException, Throwable, and Exception prevents <br /> calling methods from handling true, system-generated exceptions differently than application-generated errors.  <br /> Noncompliant Code Example <br />  <br /> public void foo(String bar) throws Throwable {  // Noncompliant <br />   throw new RuntimeException("My Message");     // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void foo(String bar) { <br />   throw new MyOwnRuntimeException("My Message"); <br /> } <br />  <br /> Exceptions <br /> Generic exceptions in the signatures of overriding methods are ignored, because overriding method has to follow signature of the throw declaration <br /> in the superclass. The issue will be raised on superclass declaration of the method (or won't be raised at all if superclass is not part of the <br /> analysis). <br />  <br /> @Override <br /> public void myMethod() throws Exception {...} <br />  <br /> Generic exceptions are also ignored in the signatures of methods that make calls to methods that throw generic exceptions. <br />  <br /> public void myOtherMethod throws Exception { <br />   doTheThing();  // this method throws Exception <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-397 - Declaration of Throws for Generic Exception  <br />    CERT, ERR07-J. - Do not throw RuntimeException, Exception, or Throwable  <br /> |CODE_SMELL|MAJOR|1
"@Override" should be used on overriding and implementing methods|Using the @Override annotation is useful for two reasons : <br />  <br />    It elicits a warning from the compiler if the annotated method doesn't actually override anything, as in the case of a misspelling.  <br />    It improves the readability of the source code by making it obvious that methods are overridden.  <br />  <br /> Noncompliant Code Example <br />  <br /> class ParentClass { <br />   public boolean doSomething(){...} <br /> } <br /> class FirstChildClass extends ParentClass { <br />   public boolean doSomething(){...}  // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> class ParentClass { <br />   public boolean doSomething(){...} <br /> } <br /> class FirstChildClass extends ParentClass { <br />   @Override <br />   public boolean doSomething(){...}  // Compliant <br /> } <br />  <br /> Exceptions <br /> This rule is relaxed when overriding a method from the Object class like toString(), hashCode(), ...|CODE_SMELL|MAJOR|2
A field should not duplicate the name of its containing class|It's confusing to have a class member with the same name (case differences aside) as its enclosing class. This is particularly so when you consider <br /> the common practice of naming a class instance for the class itself. <br /> Best practice dictates that any field or member with the same name as the enclosing class be renamed to be more descriptive of the particular <br /> aspect of the class it represents or holds. <br /> Noncompliant Code Example <br />  <br /> public class Foo { <br />   private String foo; <br />  <br />   public String getFoo() { } <br /> } <br />  <br /> Foo foo = new Foo(); <br /> foo.getFoo() // what does this return? <br />  <br /> Compliant Solution <br />  <br /> public class Foo { <br />   private String name; <br />  <br />   public String getName() { } <br /> } <br />  <br /> //... <br />  <br /> Foo foo = new Foo(); <br /> foo.getName() <br />  <br /> Exceptions <br /> When the type of the field is the containing class and that field is static, no issue is raised to allow singletons named like the type.  <br />  <br /> public class Foo { <br />   ... <br />   private static Foo foo; <br />   public Foo getInstance() { <br />     if(foo==null) { <br />       foo = new Foo(); <br />     } <br />     return foo; <br />   } <br />   ... <br /> } <br /> |CODE_SMELL|MAJOR|3
Unused assignments should be removed|A dead store happens when a local variable is assigned a value that is not read by any subsequent instruction. Calculating or retrieving a value <br /> only to then overwrite it or throw it away, could indicate a serious error in the code. Even if it's not an error, it is at best a waste of resources. <br /> Therefore all calculated values should be used. <br /> Noncompliant Code Example <br />  <br /> i = a + b; // Noncompliant; calculation result not used before value is overwritten <br /> i = compute(); <br />  <br /> Compliant Solution <br />  <br /> i = a + b; <br /> i += compute(); <br />  <br /> Exceptions <br /> This rule ignores initializations to -1, 0, 1, null, true, false and "". <br /> See <br />  <br />    MITRE, CWE-563 - Assignment to Variable without Use ('Unused Variable')  <br />    CERT, MSC13-C. - Detect and remove unused values  <br />    CERT, MSC56-J. - Detect and remove superfluous code and values  <br /> |CODE_SMELL|MAJOR|1
Assignments should not be redundant|The transitive property says that if a == b and b == c, then a == c. In such cases, there's no point in <br /> assigning a to c or vice versa because they're already equivalent.  <br /> This rule raises an issue when an assignment is useless because the assigned-to variable already holds the value on all execution paths. <br /> Noncompliant Code Example <br />  <br /> a = b; <br /> c = a; <br /> b = c; // Noncompliant: c and b are already the same <br />  <br /> Compliant Solution <br />  <br /> a = b; <br /> c = a; <br /> |CODE_SMELL|MAJOR|1
Method names should comply with a naming convention|Shared naming conventions allow teams to collaborate efficiently. This rule checks that all method names match a provided regular expression. <br /> Noncompliant Code Example <br /> With default provided regular expression ^[a-z][a-zA-Z0-9]*$: <br />  <br /> public int DoSomething(){...} <br />  <br /> Compliant Solution <br />  <br /> public int doSomething(){...} <br />  <br /> Exceptions <br /> Overriding methods are excluded.  <br />  <br /> @Override <br /> public int Do_Something(){...} <br /> |CODE_SMELL|MINOR|1
Empty statements should be removed|Empty statements, i.e. ;, are usually introduced by mistake, for example because: <br />  <br />    It was meant to be replaced by an actual statement, but this was forgotten.  <br />    There was a typo which lead the semicolon to be doubled, i.e. ;;.  <br />  <br /> Noncompliant Code Example <br />  <br /> void doSomething() { <br />   ;                                                       // Noncompliant - was used as a kind of TODO marker <br /> } <br />  <br /> void doSomethingElse() { <br />   System.out.println("Hello, world!");;                     // Noncompliant - double ; <br />   ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> void doSomething() {} <br />  <br /> void doSomethingElse() { <br />   System.out.println("Hello, world!"); <br />   ... <br />   for (int i = 0; i &lt; 3; i++) ; // compliant if unique statement of a loop <br />   ... <br /> } <br />  <br /> See <br />  <br />    CERT, MSC12-C. - Detect and remove code that has no effect or is never executed <br />    <br />    CERT, MSC51-J. - Do not place a semicolon immediately following an if, for, or while <br />   condition  <br />    CERT, EXP15-C. - Do not place a semicolon on the same line as an if, for, or while <br />   statement  <br /> |CODE_SMELL|MINOR|1
Unnecessary imports should be removed|The imports part of a file should be handled by the Integrated Development Environment (IDE), not manually by the developer.  <br /> Unused and useless imports should not occur if that is the case.  <br /> Leaving them in reduces the code's readability, since their presence can be confusing. <br /> Noncompliant Code Example <br />  <br /> package my.company; <br />  <br /> import java.lang.String;        // Noncompliant; java.lang classes are always implicitly imported <br /> import my.company.SomeClass;    // Noncompliant; same-package files are always implicitly imported <br /> import java.io.File;            // Noncompliant; File is not used <br />  <br /> import my.company2.SomeType; <br /> import my.company2.SomeType;    // Noncompliant; 'SomeType' is already imported <br />  <br /> class ExampleClass { <br />  <br />   public String someString; <br />   public SomeType something; <br />  <br /> } <br />  <br /> Exceptions <br /> Imports for types mentioned in comments, such as Javadocs, are ignored.|CODE_SMELL|MINOR|6
"throws" declarations should not be superfluous|An exception in a throws declaration in Java is superfluous if it is: <br />  <br />    listed multiple times  <br />    a subclass of another listed exception  <br />    completely unnecessary because the declared exception type cannot actually be thrown  <br />  <br /> Noncompliant Code Example <br />  <br /> void foo() throws MyException, MyException {}  // Noncompliant; should be listed once <br /> void bar() throws Throwable, Exception {}  // Noncompliant; Exception is a subclass of Throwable <br />  <br /> Compliant Solution <br />  <br /> void foo() throws MyException {} <br /> void bar() throws Throwable {} <br />  <br /> Exceptions <br /> The rule will not raise any issue for exceptions that cannot be thrown from the method body: <br />  <br />    in overriding and implementation methods  <br />    in interface default methods  <br />    in non-private methods that only throw, have empty bodies, or a single return statement.  <br />    in overridable methods (non-final, or not member of a final class, non-static, non-private), if the exception is documented with a proper <br />   JavaDoc  <br />  <br /> Also, the rule won't raise issues on RuntimeException, or one of its descendants, because explicating runtime exceptions which could <br /> be thrown can ultimately help the method's users, and can even be considered as good practice. <br />  <br /> class A extends B { <br />   @Override <br />   void doSomething() throws IOException { <br />     compute(a); <br />   } <br />  <br />   public void foo() throws IOException {} <br />  <br />   public void qix() throws MyRuntimeException {} <br />  <br />   protected void bar() throws IOException { <br />     throw new UnsupportedOperationException("This method should be implemented in subclasses"); <br />   } <br />  <br />   Object foobar(String s) throws IOException { <br />     return null; <br />   } <br />  <br />   /** <br />    * @throws IOException Overriding classes may throw this exception if they print values into a file <br />    */ <br />   protected void print() throws IOException { // no issue, method is overridable and the exception has proper javadoc <br />     System.out.println("foo"); <br />   } <br /> } <br /> |CODE_SMELL|MINOR|1
Collection.isEmpty() should be used to test for emptiness|Using Collection.size() to test for emptiness works, but using Collection.isEmpty() makes the code more readable and can <br /> be more performant. The time complexity of any isEmpty() method implementation should be O(1) whereas some implementations <br /> of size() can be O(n). <br /> Noncompliant Code Example <br />  <br /> if (myCollection.size() == 0) {  // Noncompliant <br />   /* ... */ <br /> } <br />  <br /> Compliant Solution <br />  <br /> if (myCollection.isEmpty()) { <br />   /* ... */ <br /> } <br /> |CODE_SMELL|MINOR|1
Field names should comply with a naming convention|Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that field <br /> names match a provided regular expression. <br /> Noncompliant Code Example <br /> With the default regular expression ^[a-z][a-zA-Z0-9]*$: <br />  <br /> class MyClass { <br />    private int my_field; <br /> } <br />  <br /> Compliant Solution <br />  <br /> class MyClass { <br />    private int myField; <br /> } <br /> |CODE_SMELL|MINOR|1
Unused local variables should be removed|If a local variable is declared but not used, it is dead code and should be removed. Doing so will improve maintainability because developers will <br /> not wonder what the variable is used for. <br /> Noncompliant Code Example <br />  <br /> public int numberOfMinutes(int hours) { <br />   int seconds = 0;   // seconds is never used <br />   return hours * 60; <br /> } <br />  <br /> Compliant Solution <br />  <br /> public int numberOfMinutes(int hours) { <br />   return hours * 60; <br /> } <br /> |CODE_SMELL|MINOR|1
Local variables should not be declared and then immediately returned or thrown|Declaring a variable only to immediately return or throw it is a bad practice. <br /> Some developers argue that the practice improves code readability, because it enables them to explicitly name what is being returned. However, this <br /> variable is an internal implementation detail that is not exposed to the callers of the method. The method name should be sufficient for callers to <br /> know exactly what will be returned. <br /> Noncompliant Code Example <br />  <br /> public long computeDurationInMilliseconds() { <br />   long duration = (((hours * 60) + minutes) * 60 + seconds ) * 1000 ; <br />   return duration; <br /> } <br />  <br /> public void doSomething() { <br />   RuntimeException myException = new RuntimeException(); <br />   throw myException; <br /> } <br />  <br /> Compliant Solution <br />  <br /> public long computeDurationInMilliseconds() { <br />   return (((hours * 60) + minutes) * 60 + seconds ) * 1000 ; <br /> } <br />  <br /> public void doSomething() { <br />   throw new RuntimeException(); <br /> } <br /> |CODE_SMELL|MINOR|1
Lambdas should be replaced with method references|Method/constructor references are commonly agreed to be, most of the time, more compact and readable than using lambdas, and are therefore <br /> preferred.  <br /> In some rare cases, when it is not clear from the context what kind of function is being described and reference would not increase the clarity, it <br /> might be fine to keep the lambda.  <br /> Similarly, null checks can be replaced with references to the Objects::isNull and Objects::nonNull methods, <br /> casts can be replaced with SomeClass.class::cast and instanceof can be replaced with <br /> SomeClass.class::isInstance. <br /> Note that this rule is automatically disabled when the project's sonar.java.source is lower than 8. <br /> Noncompliant Code Example <br />  <br /> class A { <br />   void process(List&lt;A&gt; list) { <br />     list.stream() <br />       .filter(a -&gt; a instanceof B) <br />       .map(a -&gt; (B) a) <br />       .map(b -&gt; b.&lt;String&gt;getObject()) <br />       .forEach(b -&gt; { System.out.println(b); }); <br />   } <br /> } <br />  <br /> class B extends A { <br />   &lt;T&gt; T getObject() { <br />     return null; <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> class A { <br />   void process(List&lt;A&gt; list) { <br />     list.stream() <br />       .filter(B.class::isInstance) <br />       .map(B.class::cast) <br />       .map(B::&lt;String&gt;getObject) <br />       .forEach(System.out::println); <br />   } <br /> } <br />  <br /> class B extends A { <br />   &lt;T&gt; T getObject() { <br />     return null; <br />   } <br /> } <br /> |CODE_SMELL|MINOR|1


## Security Hotspots

### Security hotspots count by category and priority

Category / Priority|LOW|MEDIUM|HIGH
---|---|---|---
LDAP Injection|0|0|0
Object Injection|0|0|0
Server-Side Request Forgery (SSRF)|0|0|0
XML External Entity (XXE)|0|0|0
Insecure Configuration|21|0|0
XPath Injection|0|0|0
Authentication|0|0|0
Weak Cryptography|0|0|0
Denial of Service (DoS)|0|0|0
Log Injection|0|0|0
Cross-Site Request Forgery (CSRF)|0|0|1
Open Redirect|0|0|0
Permission|0|0|0
SQL Injection|0|0|21
Encryption of Sensitive Data|0|0|0
Traceability|0|0|0
Buffer Overflow|0|0|0
File Manipulation|0|0|0
Code Injection (RCE)|0|0|0
Cross-Site Scripting (XSS)|0|0|0
Command Injection|0|0|0
Path Traversal Injection|0|0|0
HTTP Response Splitting|0|0|0
Others|0|0|0


### Security hotspots

Category|Name|Priority|Severity|Count
---|---|---|---|---
Insecure Configuration|Delivering code in production with debug features activated is security-sensitive|LOW|MINOR|21
SQL Injection|Formatting SQL queries is security-sensitive|HIGH|MAJOR|21
Cross-Site Request Forgery (CSRF)|Disabling CSRF protections is security-sensitive|HIGH|CRITICAL|1
